Banner logo

Palazzo in Venedig? Restaurant in Krakau? Hotel in Agadir? – Mach mit beim Wikivoyage Bearbeitungs-Marathon und vervollständige unsere Reiseführer!
Ausblenden
LINQ
aus Wikipedia, der freien Enzyklopädie
Dies ist die aktuelle Version dieser Seite, zuletzt bearbeitet am 10. Februar 2018 um 18:06 Uhr durch Joschi71 ( Diskussion | Beiträge ) ( → ‎ Skalar-Selektoren: typo ) .
( Unterschied ) ← Nächstältere Version | Aktuelle Version (Unterschied) | Nächstjüngere Version → (Unterschied)
Wechseln zu: Navigation , Suche
Eine markierte Version dieser Seite, die am 10. Februar 2018 freigegeben wurde, basiert auf dieser Version.
	Dieser Artikel behandelt das Verfahren zum Zugriff auf Daten. Zum Vergnügungskomplex in Las Vegas siehe The LINQ .

LINQ (Abkürzung für Language Integrated Query ; Aussprache Link ) ist ein programmtechnisches Verfahren von Microsoft zum Zugriff auf Daten. LINQ wurde federführend von Erik Meijer entwickelt [1] und erschien erstmals mit Visual Studio 2008.
Inhaltsverzeichnis
 [ Verbergen ] 

    1 Ziel von LINQ
    2 Arbeitsweise
    3 Wichtige Konzepte
        3.1 Verzögerte Auswertung
        3.2 Auflösung von Erweiterungsmethoden
    4 Wichtige Operatoren
        4.1 From
        4.2 Where
        4.3 Select
        4.4 Group
        4.5 Into
        4.6 Orderby und ThenBy
        4.7 Reverse
        4.8 Join
        4.9 Let
        4.10 Any
        4.11 Contains
        4.12 Skip und Take
        4.13 Distinct
        4.14 Union, Intersect und Except
        4.15 Aggregate
        4.16 Zip
        4.17 Concat
        4.18 SequenceEqual
        4.19 SelectMany
        4.20 Skalar-Selektoren
    5 Erweitern von LINQ
        5.1 Definition eigener Monaden
            5.1.1 Identität
            5.1.2 Maybe
        5.2 Definieren eigener Operatoren
        5.3 Implementierung eigener LINQ-Provider
    6 Reactive Extensions
    7 Beispiele
        7.1 LINQ to DataSet
        7.2 LINQ to XML
        7.3 LINQ mit Rx
    8 Siehe auch
    9 Literatur
    10 Weblinks
    11 LINQ in anderen Programmiersprachen
    12 Einzelnachweise

Ziel von LINQ [ Bearbeiten | Quelltext bearbeiten ]

Die Daten, auf die ein Programm zugreift, stammen aus unterschiedlichen Quellen. [2] Dazu gehören [3]

    interne Quellen wie Felder sowie Objekt -Listen und -Hierarchien;
    externe Quellen wie XML -Dokumente, Datenbanktabellen , Textdateien, Excel -Dateien, E-Mail-Nachrichten, SharePoint -Listen und viele andere.

Jede dieser Datenquellen hat ihre eigenen Zugriffsmethoden. Dies führt dazu, dass sich der Programmierer in jedem Einzelfall mit den Details der jeweiligen Methode beschäftigen muss. Ferner muss jedes Mal das Programm geändert werden, wenn Daten aus einer Quelle in eine Quelle eines anderen Typs verschoben werden.

LINQ versucht dieses Problem zu beseitigen, indem es innerhalb der Entwicklungsplattform .NET eine einheitliche Methode für jeglichen Datenzugriff zur Verfügung stellt. Die Syntax der Abfragen in LINQ ist ähnlich der von SQL . Im Unterschied zu SQL stellt LINQ jedoch auch Sprachelemente zur Verfügung, die zum Zugriff auf hierarchische und Netzwerk-Strukturen geeignet sind, indem sie die dort vorhandenen Beziehungen ausnutzen. [4]
Arbeitsweise [ Bearbeiten | Quelltext bearbeiten ]
Wichtige LINQ-Anbieter [5]

LINQ ist eine Sammlung von Erweiterungsmethoden, die auf Monaden operieren. [6] [7] Zudem gibt es in einigen .NET Sprachen wie C#, VB.NET und F# eigene Schlüsselwörter für eine vorbestimmte Menge an LINQ-Methoden. [8] [9] Monaden werden in .NET als generische Klassen oder Interfaces mit einzelnem Typargument (z. B. IEnumerable < T > , IObservable < T > ) abgebildet.

LINQ-Anweisungen sind unmittelbar als Quelltext in .NET-Programme eingebettet. [10] Somit kann der Code durch den Compiler auf Fehler geprüft werden. Andere Verfahren wie ADO und ODBC hingegen verwenden Abfragestrings. Diese können erst zur Laufzeit interpretiert werden; dann wirken Fehler gravierender und sind schwieriger zu analysieren.

Innerhalb des Quellprogramms in C# oder VB.NET präsentiert LINQ die Abfrage-Ergebnisse als streng typisierte Aufzählungen. [11] Somit gewährleistet es Typsicherheit bereits zur Übersetzungszeit.

Sogenannte LINQ-Anbieter [2] (engl: LINQ provider ) übersetzen die LINQ-Anweisungen in die speziellen Zugriffsmethoden der jeweiligen Datenquelle. Innerhalb der .NET-Plattform stehen unter anderem folgende Anbieter zur Verfügung: [12]

    LINQ to Objects zum Zugriff auf Objektlisten und -Hierarchien im Arbeitsspeicher
    LINQ to SQL zur Abfrage und Bearbeitung von Daten in MS-SQL -Datenbanken
    LINQ to Entities zur Abfrage und Bearbeitung von Daten im relationalen Modell von ADO.NET ; [13]
    LINQ to XML zum Zugriff auf XML-Inhalte
    LINQ to DataSet zum Zugriff auf ADO.NET-Datensammlungen und -Tabellen
    LINQ to SharePoint zum Zugriff auf SharePoint-Daten. [14]

Wichtige Konzepte [ Bearbeiten | Quelltext bearbeiten ]

Die Beispiele sind, sofern nicht anders angegeben, in C# .
Verzögerte Auswertung [ Bearbeiten | Quelltext bearbeiten ]

LINQ-Ausdrücke werden nicht bei ihrer Definition ausgeführt, sondern wenn der Wert abgefragt wird. Dies wird als Lazy Evaluation (auch deferred evaluation ) bezeichnet. Dadurch kann die Abfrage auch mehrfach verwendet werden.

  var  numbers  =  new  List < int >()  { 1 , 2 , 3 , 4 };  // list with 4 numbers 

// query is defined but not evaluated 
var  query  =  from  x  in  numbers 
            select  x ; 

numbers . Add ( 5 );  // add a 5th number 

// now the query gets evaluated 
Console . WriteLine ( query . Count ());  // 5 

numbers . Add ( 6 );  // add a 6th number 

Console . WriteLine ( query . Count ());  // 6 

Die verzögerte Auswertung kann auf verschiedene Weisen implementiert werden. Beispielsweise verwendet LINQ to Objects Delegates , während LINQ to SQL stattdessen das IQueryable < T > -Interface implementiert. Um die Veränderung des Ergebnisses der Abfrage zu verhindern, muss diese in einen anderen Typ konvertiert (englisch: conversion ) werden. Hierzu dienen Konvertierungsmethoden wie AsEnumerable () , ToArray () , ToList () , ToDictionary () , ToLookup () , OfType () , Cast () usw.

Falls die LINQ-Abfrage eine Funktion aufruft, die eine Ausnahmebehandlung erfordert, so muss der Try-Catch-Block die Verwendung der Abfrage umklammern und nicht deren Erstellung.
Auflösung von Erweiterungsmethoden [ Bearbeiten | Quelltext bearbeiten ]

LINQ-Funktionen werden als Erweiterungsmethoden (englisch: extension method ) implementiert. Gegeben sei z. B. eine Klasse, welche eine Liste von Angestellten repräsentiert:

  public  sealed  class  Employees  :  List < Employee > 
{ 
   public  Employees ( IEnumerable < Employee >  items )  :  base ( items )  {  } 
} 

Über eine Erweiterungsmethode kann nun etwa die Where () -Methode implementiert werden:

  public  static  class  EmployeeExtension 
{ 
   public  static  IEnumerable < Employee >  Where ( this  Employees  source ,  Func < Employee ,  bool >  predicate ) 
   { 
      return  ( source . AsEnumerable (). Where ( predicate )); 
   } 

   public  static  IEnumerable < Employee >  Where ( this  Employee  source ,  Func < Employee ,  int ,  bool >  predicate ) 
   { 
      return  ( source . AsEnumerable (). Where ( predicate )); 
   } 
} 

Bestimmte .NET-Sprachen besitzen eigene Schlüsselwörter, um die Methoden aufzurufen:

  var  query  =  
   from  e  in  employees 
   where  e . DepartmentId  ==  5 
   select  e ; 

Diese Schlüsselwörter werden vom Compiler in die entsprechenden Methodenaufrufe aufgelöst:

  var  query  =  employees . Where ( e  =>  e . DepartmentId  ==  5 ). Select ( e  =>  e ); 

Da es sich um Erweiterungsmethoden handelt, muss der Compiler die Methodenaufrufe in einen Aufruf der Methoden der passenden Erweiterungsklasse auflösen:

  var  query  =  Enumerable . Select ( EmployeeExtension . Where ( developers ,  e  =>  e . DepartmentId  ==  5 ),  e  =>  e ); 


Wichtige Operatoren [ Bearbeiten | Quelltext bearbeiten ]
From [ Bearbeiten | Quelltext bearbeiten ]

From definiert die Datenquelle einer Abfrage ( query ) oder Unterabfrage ( subquery ), sowie eine Bereichsvariable ( range variable ) die ein einzelnes Element der Datenquelle ( data source ) repräsentiert.

  from  rangeVariable  in  dataSource 
// ... 

Abfragen können mehrere from -Operationen besitzen, um Joins von mehreren Datenquellen zu ermöglichen. Hierbei gilt zu beachten, dass die Join-Bedingung bei mehreren from -Operationen durch die Datenstruktur definiert wird und sich vom Konzept eines Joins in Relationalen Datenbanken unterscheidet.

  var  queryResults  =  
   from  c  in  customers 
   from  o  in  orders 
   select  new  {  c . Name ,  o . OrderId ,  o . Price  }; 

oder kürzer:

  var  queryResults  =  
   from  c  in  customers ,  o  in  orders 
   select  new  {  c . Name ,  o . OrderId ,  o . Price  }; 

Where [ Bearbeiten | Quelltext bearbeiten ]

Where definiert einen Filter auf den auszuwählenden Daten.

  var  queryResults  =  
   from  c  in  customers 
   from  o  in  orders 
   where  o . Date  >  DateTime . Now  -  TimeSpan ( 7 , 0 , 0 , 0 )  // only orders from last week 
   select  new  {  c . Name ,  o . OrderId ,  o . Price  }; 

Select [ Bearbeiten | Quelltext bearbeiten ]

Select definiert die Form des Ergebnisses der LINQ-Abfrage.
Group [ Bearbeiten | Quelltext bearbeiten ]

Group wird verwendet um Elemente nach einem bestimmten Schlüssel zu gruppieren:

  var  groupedEmployees  =  
   from  e  in  Employees 
   group  e  by  e . Department ;  // group by department 

Als Schlüssel kann auch ein anonymer Typ verwendet werden, der sich aus mehreren Schlüsseln zusammensetzt:

  var  groupedEmployees  =  
   from  e  in  Employees 
   group  e  by  new  {  e . Department  ,  e . Age  };  // group by department and age 

Into [ Bearbeiten | Quelltext bearbeiten ]

Into kann verwendet werden um das Ergebnis einer select , group oder join -Operation in einer temporären Variable zu speichern.

  var  groupedEmployees  =  
   from  e  in  Employees 
   group  e  by  e . Department  into  EmployeesByDepartment 
   select  new  {  Department  =  EmployeesByDepartment . Key ,  EmployeesByDepartment . Count ()  }; 

Orderby und ThenBy [ Bearbeiten | Quelltext bearbeiten ]

Orderby und ThenBy wird verwendet um eine Liste von Elementen in aufsteigender Reihenfolge zu sortieren.

  var  groupedEmployees  =  
   from  e  in  Employees 
   orderby  e . Age  // order employees by age; youngest first 
   thenby  e . Name  // order same-age employees by name; sort A-to-Z 
   select  e ; 

Mit Hilfe von OrderByDescending und ThenByDescending wird die Liste in absteigender Reihenfolge sortiert:

  var  groupedEmployees  =  
   from  e  in  Employees 
   orderby  e . Age  descending  // oldest first 
   thenby  e . Name  descending  // sort Z-to-A 
   select  e ; 

Reverse [ Bearbeiten | Quelltext bearbeiten ]

Reverse kehrt die Reihenfolge der Elemente um.
Join [ Bearbeiten | Quelltext bearbeiten ]

Join ermöglicht Inner Joins , Group Joins und Left Outer Joins .

Inner Join
    Ein Inner Join bildet die äußere Datenquelle auf die innere Datenquelle ab und liefert ein „flaches“ Ergebnis zurück. Elemente der äußeren Datenquelle, zu denen kein passendes Element der inneren Datenquelle existiert, werden verworfen.

  var  productCategories  =  
   from  c  in  categories  // outer datasource 
   join  p  in  products  // inner datasource 
   on  c . CategoryId  equals  p . CategoryId  // categories without products are ignored 
   select  new  {  c . CategoryName ,  p . ProductName  }; 

Group Join
    Ein Group Join erzeugt eine hierarchische Ergebnismenge. Hierbei werden die Elemente der inneren Datenquelle mit den entsprechenden Elementen der äußeren Datenquelle gruppiert. Elemente zu denen kein entsprechendes Element der äußeren Datenquelle existiert, werden mit einem leeren Array verbunden.

  var  productCategories  =  
   from  c  in  categories 
   join  p  in  products 
   on  c . CategoryId  equals  p . CategoryId 
   into  productsInCategory 
   select  new  {  c . CategoryName ,  Products  =  productsInCategory  }; 

    Ein Group Join ist in SQL nicht abbildbar, da SQL keine hierarchische Ergebnismenge zulässt. VB.NET besitzt mit Group Join ein eigenes Schlüsselwort.

Left Outer Join
    Ein Left Outer Join bildet die äußere Datenquelle auf die innere Datenquelle ab und liefert ein „flaches“ Ergebnis zurück. Elemente der äußeren Datenquelle, zu denen kein passendes Element der inneren Datenquelle existiert, werden mit einem Standardwert versehen. Um den Standardwert zu definieren wird die DefaultIfEmpty () -Erweiterungsmethode verwendet.

  var  productCategories  =  
   from  c  in  categories 
   join  p  in  products 
   on  c . CategoryId  equals  p . CategoryId 
   into  productsInCategory 
   from  pic  in  productsInCategory . DefaultIfEmpty ( 
      new  Product ( CategoryId  =  0 ,  ProductId  =  0 ,  ProductName  =  String . Empty )) 
   select  new  {  c . CategoryName ,  p . ProductName  }; 

Let [ Bearbeiten | Quelltext bearbeiten ]

Let ermöglicht es das Ergebnis einer Teilabfrage in einer Variable zu speichern um diese später in der Abfrage verwenden zu können.

  var  ordersByProducts  =  
   from  c  in  categories 
   join  p  in  products 
   on  c . CategoryId  equals  p . CategoryId 
   into  productsByCategory 
   let  ProductCount  =  productsByCategory . Count () 
   orderby  ProductCount 
   select  new  {  c . CategoryName ,  ProductCount  }; 

Any [ Bearbeiten | Quelltext bearbeiten ]

Any wird verwendet um festzustellen, ob eine Sequenz leer ist oder ein bestimmtes Prädikat enthält.

  bool  containsAnyElements  =  Enumerable . Empty < int >(). Any ();  // false 
bool  containsSix  =  Enumerable . Range ( 1 , 10 ). Any ( x  =>  x  ==  6 );  // true 

Contains [ Bearbeiten | Quelltext bearbeiten ]

Contains wird verwendet um festzustellen, ob ein bestimmter Wert in einer Sequenz enthalten ist.

  bool  containsSix  =  Enumerable . Range ( 1 , 10 ). Contains ( 6 );  // true 

Skip und Take [ Bearbeiten | Quelltext bearbeiten ]

Skip wird verwendet um eine bestimmte Anzahl von Elementen einer Sequenz zu überspringen. Take wird verwendet um eine maximale Anzahl von Elementen einer Sequenz auszuwählen.

  IEnumerable < int >  Numbers  =  Enumerable . Range ( 1 , 10 ). Skip ( 2 ). Take ( 5 );  // {3,4,5,6,7} 

Zusätzlich sind die Erweiterungsmethoden SkipWhile () und TakeWhile () definiert, für die in VB.NET eigene Schlüsselwörter definiert sind. Diese Methoden erlauben die Verwendung eines Prädikats, welches definiert welche Elemente übersprungen bzw. ausgewählt werden.
Distinct [ Bearbeiten | Quelltext bearbeiten ]

Distinct wird verwendet um eindeutige Elemente einer Sequenz auszuwählen.

  IEnumerable < int >  MultipleNumbers  =  new  List < int >()  { 0 , 1 , 2 , 3 , 2 , 1 , 4 }; 
IEnumerable < int >  DistinctNumbers  =  MultipleNumbers . Distinct ();  // {0,1,2,3,4} 

Union, Intersect und Except [ Bearbeiten | Quelltext bearbeiten ]

Für eine Liste von Elementen können die Mengenoperatoren Union, Intersect und Except eingesetzt werden:

  var  NumberSet1  =  { 1 , 5 , 6 , 9 }; 
var  NumberSet2  =  { 4 , 5 , 7 , 11 }; 

var  union  =  NumberSet1 . Union ( NumberSet2 );  // 1,5,6,9,4,7,11 
var  intersect  =  NumberSet1 . Intersect ( NumberSet2 );  // 5 
var  except  =  NumberSet1 . Except  ( NumberSet2 );  // 1,6,9 

Aggregate [ Bearbeiten | Quelltext bearbeiten ]

Aggregate wird verwendet um eine Aggregat-Funktion auf eine Datenquelle anzuwenden.

  var  nums  =  new []{ 1 , 2 , 3 , 4 , 5 }; 
var  sum  =  nums . Aggregate (  ( a , b )  =>  a  +  b );  // sum = 1+2+3+4+5 = 15 

Zudem sind wichtige Aggregat-Funktionen vordefiniert. Vordefinierte Aggregat-Funktionen sind etwa Count () , LongCount () , Sum () , Min () , Max () und Average () .
Zip [ Bearbeiten | Quelltext bearbeiten ]

Zip kombiniert zwei Sequenzen miteinander bis eine Sequenz zu Ende ist.

  1  IEnumerable < string >  Days  =  new  List < string >()  {  "Monday" ,  "Tuesday" ,  "Wednesday" ,  "Thursday" ,  "Friday" ,  "Saturday" ,  "Sunday" }; 
2  IEnumerable < int >  Numbers  =  Enumerable . Range ( 1 , 10 );  // {1,2,3,4,5,6,7,8,9,10} 
3  // Numbers 8..10 will be ignored 
4  IEnumerable < string >  NumberedDays  =  Days . Zip ( Numbers ,  ( day ,  number )  =>  String . Format ( "{0}:{1}" ,  number ,  day )  );  // {"1:Monday", "2:Tuesday", ..., "7:Sunday"} 

Concat [ Bearbeiten | Quelltext bearbeiten ]

Concat hängt an eine Sequenz eine weitere Sequenz gleichen Typs.
SequenceEqual [ Bearbeiten | Quelltext bearbeiten ]

SequenceEqual prüft ob zwei Sequenzen die gleiche Länge aufweisen und ob die Elemente an der jeweiligen Position der entsprechenden Sequenzen gleich sind. Zum Vergleich wird entweder das IEqualityComparer < T > Interface, die Equals () -Methode von TSource , oder die GetHashCode () -Methode abgefragt.
SelectMany [ Bearbeiten | Quelltext bearbeiten ]

SelectMany [15] wird im Wesentlichen dazu eingesetzt eine Hierarchie abzuflachen. SelectMany funktioniert hierbei wie der Bind-Operator >>= , auch shovel ( Schaufel ) genannt, in Haskell .

  class  Book 
{ 
   public  string  Title  {  get ;  set ;  } 
   public  List < Author >  Authors  {  get ;  set ;  } 
} 
class  Author 
{ 
   public  string  Name  {  get ;  set ;  } 
} 
class  Foo 
{ 
   public  IEnumerable < string >  GetAutorsFromBooks ( IEnumerable < Book >  books ) 
   { 
      // Input-Monad: Enumerable Book Author 
      // Output-Monad: Enumerable Author 
      return  books . SelectMany (  book  =>  book . Authors ); 
   } 
} 

Ein typischer Anwendungsfall für die Abflachung einer Hierarchie ist es alle Dateien in einem Verzeichnis, sowie den Unterverzeichnissen des Verzeichnisses, aufzulisten.

  IEnumerable < string >  GetFilesInSubdirectories ( string  rootDirectory ) 
{ 
   var  directoryInfo  =  new  DirectoryInfo ( rootDirectory );  // get the root directory 
   return  directoryInfo . GetDirectories ()  // get directories in the root directory 
                       . SelectMany ( dir  =>  GetFilesInSubdirectories ( dir . FullName ))  // recursively flatting the hierarchy of directories 
                       . Concat ( directoryInfo . GetFiles (). Select ( file  =>  file . FullName ));  // get the file name for each file in the directories 
} 

Skalar-Selektoren [ Bearbeiten | Quelltext bearbeiten ]

LINQ definiert verschiedene Selektoren für skalare Ergebnisse:
skalare LINQ Selektoren Methode 	Ergebnis
ElementAt(n) 	Gibt das n-te Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Wirft eine Exception, falls weniger als n Ergebnisse zurückgeliefert werden.
ElementAtOrDefault(n) 	Gibt das n-te Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Gibt den Standardwert zurück, falls weniger als n Ergebnisse zurückgeliefert werden.
First() 	Gibt das erste Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Wirft eine Exception, falls keine Ergebnisse zurückgeliefert werden.
FirstOrDefault() 	Gibt das erste Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Gibt den Standardwert zurück, falls keine Ergebnisse zurückgeliefert werden.
Last() 	Gibt das letzte Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Wirft eine Exception, falls keine Ergebnisse zurückgeliefert werden.
LastOrDefault() 	Gibt das letzte Element zurück, falls die Anfrage ein oder mehrere Ergebnisse liefert. Gibt den Standardwert zurück, falls keine Ergebnisse zurückgeliefert werden.
Single() 	Gibt das eine Element zurück, welches die Anfrage liefert. Wirft eine Exception, falls keine oder mehrere Ergebnisse zurückgeliefert werden.
SingleOrDefault() 	Gibt das eine Element zurück, welches die Anfrage liefert. Gibt den Standardwert zurück, falls keine Ergebnisse geliefert werden. Wirft eine Exception, falls mehrere Ergebnisse zurückgeliefert werden.
Erweitern von LINQ [ Bearbeiten | Quelltext bearbeiten ]
Definition eigener Monaden [ Bearbeiten | Quelltext bearbeiten ]

LINQ kann auf beliebige Monaden angewendet werden. Monaden sind hierbei Adapter (englisch: wrapper ) für einen bestimmten Typ. Vordefinierte Monaden sind z. B. IEnumerable < T > , IList < T > , Nullable < int > und Task < T > .

Jedoch können auch eigene Monaden wie z. B. IRepository < T > oder IHandler < T > erstellt werden, um die Funktionalität von LINQ zu erweitern. Hierfür müssen passende Erweiterungsmethoden definiert werden. Die Verwendung von Monaden dient hierbei dazu die Menge an Boilerplate -Code zu reduzieren.
Identität [ Bearbeiten | Quelltext bearbeiten ]

Die einfachste Monade ist die Identität, welche in .NET üblicherweise als Identity < T > bezeichnet wird:

  public  class  Identity < T > 
{ 
    public  T  Value  {  get ;  private  set ;  } 

    public  Identity ( T  value ) 
    { 
        Value  =  value ; 
    } 
} 

Für diese Klasse lassen sich nun die folgenden Erweiterungsmethoden erstellen:

  // Unit-Methode 
// Konvertiert einen beliebigen Wert in eine Identität 
public  static  Identity < T >  ToIdentity < T >( this  T  value ) 
{ 
   return  new  Identity < T >( value ); 
} 

// Bind-Methode 
// Verknüpft Funktionen die eine Identität zurückgeben 
public  static  Identity < B >  Bind < A ,  B >( this  Identity < A >  m ,  Func < A ,  Identity < B >>  f ) 
{ 
    return  f ( m . Value ); 
} 

Diese Monade kann nun als Lambda-Ausdruck (als Arbitrary Composition ) verwendet werden:

  var  hello  =  "Hello" . ToIdentity (). Bind ( h  =>  "Monad" . ToIdentity (). Bind (  m  =>  String . Format ( "{0} {1}!" ,  h ,  m )  )); 

Console . WriteLine ( hello . Value );  // "Hello Monad!" 

Um die Monade in LINQ verwenden zu können, muss eine SelectMany () -Erweiterungsmethode implementiert werden. Diese ist lediglich ein Alias für Bind () . Es besteht daher die Möglichkeit

    die Bind () -Methode umzubenennen bzw. zu kapseln
    die Bind () -Methode mit Funktionskomposition zu erstellen und umzubenennen bzw. zu kapseln
    beides:

  // SelectMany = Bind 
public  static  Identity < B >  SelectMany < A ,  B >( this  Identity < A >  m ,  Func < A ,  Identity < B >>  f ) 
{ 
    return  Bind ( m ,  f ); 
    // alternativ mit aufgelöstem Bind(): 
    // return f(m.Value); 
} 

// Bind mit Funktionskomposition 
public  static  Identity < C >  SelectMany < A ,  B ,  C >( this  Identity < A >  m ,  Func < A ,  Identity < B >>  f ,  Func < A ,  B ,  C >  select ) 
{ 
    return  select ( m . Value ,  m . Bind ( f ). Value ). ToIdentity (); 

    // alternativ mit aufgelöstem Bind(): 
    // return select(m.Value, f(m.Value).Value).ToIdentity(); 
} 

Die Monade kann nun mit Hilfe von LINQ-Schlüsselwörtern verarbeitet werden:

  var  hello  =  from  h  in  "Hello" . ToIdentity () 
            from  m  in  "Monad" . ToIdentity () 
            select  String . Format ( "{0} {1}!" ,  h ,  m ); 

Console . WriteLine ( hello . Value );  // "Hello Monad!" 

Maybe [ Bearbeiten | Quelltext bearbeiten ]

Eine weitere einfache Monade ist Maybe < T > , welche ähnlich funktioniert wie die Nullable < T > -Struktur [16] [17] . Die Maybe-Monade lässt sich hierbei auf verschiedene Arten implementieren:

Variante 1
    HasValue-Eigenschaft bestimmt ob Maybe Nothing (dh. leer) ist.

Definition der Monade:

  class  Maybe < T > 
{ 
    public  readonly  static  Maybe < T >  Nothing  =  new  Maybe < T >(); 

    public  T  Value  {  get ;  private  set ;  } 

    public  bool  HasValue  {  get ;  private  set ;  } 

    Maybe () 
    { 
        HasValue  =  false ; 
    } 

    public  Maybe ( T  value ) 
    { 
        Value  =  value ; 
        HasValue  =  true ; 
    } 

    public  override  string  ToString () 
    { 
        return  ( HasValue )  ?  Value . ToString ()  :  String . Empty ; 
    } 
} 

Definition der Unit-Methode:

  public  static  Maybe < T >  ToMaybe < T >( this  T  value ) 
{ 
    return  new  Maybe < T >( value ); 
} 

Definition der Bind-Methode:

  private  static  Maybe < U >  Bind < T ,  U >( this  Maybe < T >  m ,  Func < T ,  Maybe < U >>  f ) 
{ 
    return  ( m . HasValue )  ?  f ( m . Value )  :  Maybe < U >. Nothing ; 
} 

public  static  Maybe < U >  SelectMany < T ,  U >( this  Maybe < T >  m ,  Func < T ,  Maybe < U >>  f ) 
{ 
    return  Bind < T ,  U >( m ,  f ); 
} 

public  static  Maybe < C >  SelectMany < A ,  B ,  C >( this  Maybe < A >  m ,  Func < A ,  Maybe < B >>  f ,  Func < A ,  B ,  C >  select ) 
{ 
    return  m . Bind ( x  =>  f ( x ). Bind ( y  =>  select ( x , y ). ToMaybe ())); 
} 

Verwendung:

  // null-propagation of nullables 
var  r  =  from  x  in  5. ToMaybe () 
        from  y  in  Maybe < int >. Nothing 
        select  x  +  y ; 

Console . WriteLine ( r . Value );  // String.Empty 

Variante 2
    konkreter Typ bestimmt ob Nothing oder Something

Definition der Monade:

  public  interface  Maybe < T >{} 

public  class  Nothing < T >  :  Maybe < T > 
{ 
    public  override  string  ToString () 
    { 
        return  String . Empty ; 
    } 
} 

public  class  Something < T >  :  Maybe < T > 
{ 
    public  T  Value  {  get ;  private  set ;  } 

    public  Something ( T  value ) 
    { 
        Value  =  value ; 
    } 

    public  override  string  ToString () 
    { 
        return  Value . ToString (); 
    } 
} 

Definition der Unit-Methode:

  public  static  Maybe < T >  ToMaybe < T >( this  T  value ) 
{ 
    return  new  Something < T >( value ); 
} 

Definition der Bind-Methode:

  private  static  Maybe < B >  Bind < A ,  B >( this  Maybe < A >  m ,  Func < A ,  Maybe < B >>  f ) 
{ 
    var  some  =  m  as  Something < A >; 
    return  ( some  ==  null )  ?  new  Nothing < B >()  :  f ( some . Value ); 
} 

public  static  Maybe < B >  SelectMany < A ,  B >( this  Maybe < A >  m ,  Func < A ,  Maybe < B >>  f ) 
{ 
    return  Bind < A ,  B >( m ,  f ); 
} 

public  static  Maybe < C >  SelectMany < A ,  B ,  C >( this  Maybe < A >  m ,  Func < A ,  Maybe < B >>  f ,  Func < A ,  B ,  C >  select ) 
{ 
    return  m . Bind ( x  =>  f ( x ). Bind ( y  =>  select ( x , y ). ToMaybe ())); 
} 

Verwendung:

  var  r  =  from  x  in  5. ToMaybe ()  // Something<int> 
        from  y  in  new  Nothing < int >() 
        select  x  +  y ; 

Console . WriteLine ( r );  // String.Empty 

Definieren eigener Operatoren [ Bearbeiten | Quelltext bearbeiten ]

Operatoren in LINQ lassen sich erweitern, indem eine passende Erweiterungsmethode bereitgestellt wird. Hierbei können auch Standardoperatoren überschrieben werden.

Beispiel 1
    Rückgabe von Personen, die zu einem bestimmten Datum Geburtstag haben.

  public  static  class  PersonExtensions 
{ 
   public  static  IEnumerable < TPerson >  FilterByBirthday < TPerson >( this  IEnumerable < TPerson >  persons )  where  TPerson  :  Person 
   { 
      return  FilterByBirthday ( persons ,  DateTime . Now ); 
   } 

   public  static  IEnumerable < TPerson >  FilterByBirthday < TPerson >( this  IEnumerable < TPerson >  persons ,  DateTime  date )  where  TPerson  :  Person 
   { 
      var  birthdayPersons  =  select  p  in  persons 
                            where  p . Birthday . Day  ==  date . Day 
                            where  p . Birthday . Month  ==  date . Month 
                            select  p ; 

      // return the list of persons 
      foreach ( Person  p  in  birthdayPersons ) 
         yield  return  p ; 
   } 
} 

    Aufrufen der neuen Erweiterungsmethode

  personsToCongratulate  =  persons . FilterByBirthday (); 

Beispiel 2
    Definition einer Methode, welche die Menge der ältesten Personen einer Liste zurückliefert. Es soll zudem eine Delegate-Funktion angegeben werden können, um etwa verstorbene Personen auszufiltern.

  public  static  class  PersonExtensions 
{ 
   public  static  IEnumerable < TPerson >  Oldest < TPerson >( this  IEnumerable < TPerson >  source ,  Func < TPerson ,  Boolean >  predicate )  where  TPerson  :  Person 
   { 
      // filter Persons for criteria 
      var  persons  =  from  p  in  source 
                    where  predicate ( p ) 
                    select  p ; 

      // determine the age of the oldest persons 
      int  oldestAge  =  ( from  p  in  persons 
                       orderby  p . Age  descending 
                       select  p . Age ). First (); 

      // get the list of the oldest persons 
      var  oldestPersons  =  select  p  in  persons 
                          where  p . Age  ==  youngestAge 
                          select  p ; 

      // return the list of youngest persons 
      foreach ( Person  p  in  oldestPersons ) 
         yield  return  p ; 
   } 

   public  static  IEnumerable < TPerson >  Oldest ( this  IEnumerable < TPerson >  source )  where  TPerson  :  Person 
   { 
      return  Oldest ( source ,  x  =>  true ); 
   } 
} 

    Aufrufen der neuen Erweiterungsmethode

  oldestLivingPersons  =  persons . Oldest ( p  =>  p . Living  ==  true ); 

Implementierung eigener LINQ-Provider [ Bearbeiten | Quelltext bearbeiten ]

Das schreiben eigener LINQ-Provider bietet sich an, wenn ein Service aufgerufen werden soll, welches eine bestimmte Syntax ( SQL , XML , etc.) verlangt. Um dies zu ermöglichen muss das IQueryable -Interface implementiert werden. Über dieses Interface kann der LINQ-Ausdrucksbaum analysiert und in das passende Zielformat umgewandelt werden.


Reactive Extensions [ Bearbeiten | Quelltext bearbeiten ]

Die Reactive Extensions (kurz: Rx ) sind eine Erweiterung von LINQ, welche auf IObservable < T > statt IEnumerable < T > arbeitet. Es handelt sich dabei um eine Implementierung des Beobachter-Entwurfsmusters .
Vergleich von Rx mit LINQ Operationsart gemäß dem CQS -Prinzip 	Kommando (Command) 	Abfrage (Query)
Definition 	hat Seiteneffekte 	liefert Daten zurück
Muster 	Observer 	Iterator
Implementierung im .NET Framework 	Rx (IObservable) 	LINQ (IEnumerable)
Muster 	Pipes und Filter 	Map/Reduce
Asynchronität 	Alle Kommandos können asynchron implementiert werden. 	

Ergebnisse werden mit Hilfe von

    asynchronen Benachrichtigungen oder
    Tokens für Status-Polling

zurückgeliefert.

Die Rx ermöglichen eine Ereignisgesteuerte Programmierung ohne Rückruffunktionen . Gelegentlich werden die Rx dabei als „LINQ to Events“ beschrieben.
Beispiele [ Bearbeiten | Quelltext bearbeiten ]
LINQ to DataSet [ Bearbeiten | Quelltext bearbeiten ]

Folgendes Beispiel zeigt die Abfrage einer Tabelle mit Linq. Vorausgesetzt wird eine bestehende Access -Datenbank unter dem Pfad: C:\database.mdb mit einer Tabelle Products , die die Felder ID , Name und EanCode enthält.

Die Tabelle wird als Klasse nachgebildet und mittels Attributen mit Metadaten versehen, die das Mapping auf die Datenbank beschreiben.

Dazu muss in der Projektmappe unter References ein Verweis auf die System.Data.Linq.Dll hinzugefügt werden.

      using  System.Data.Linq.Mapping ; 

[Table(Name = "Products")] 
    class  Product 
    { 
[Column(Name = "id", IsPrimaryKey = true)] 
        public  int  ID ; 

[Column(Name = "Name")] 
        public  string  Name ; 

[Column(Name = "Ean")] 
        public  string  EanCode ; 
    } 

Nun kann man die Tabelle abfragen. In folgendem Beispiel werden alle Produkte aufgelistet, deren Produktbezeichnung mit einem A beginnt. Die Produkte werden nach ihrer ID sortiert.

  using  System.Configuration ;   // for ConfigurationManager 
using  System.Data ;            // for all interface types 
using  System.Data.Common ;     // for DbProviderFactories 

class  Foo () 
{ 
   public  static  void  Main ()  { 
      // get connection settings from app.config 
      var  cs  =  ConfigurationManager . ConnectionStrings [ "MyConnectionString" ]; 
      var  factory  =  DbProviderFactories . GetFactory ( cs . ProviderName ); 

      using ( IDbConnection  connection  =  new  factory . CreateConnection ( cs . ConnectionString )) 
      { 
         connection . Open (); 

         DataContext  db  =  new  DataContext ( connection ); 

         Table < Product >  table  =  db . GetTable < Product >(); 

         var  query  =  from  p  in  table 
                     where  p . Name . StartsWith ( "A" ) 
                     orderby  p . ID 
                     select  p ; 

         foreach  ( var  p  in  query ) 
            Console . WriteLine ( p . Name ); 
      } 
   } 
} 

Alternativ können auch sogenannte Erweiterungsmethoden mit Lambda-Ausdrücken verwendet werden. In solche werden LINQ-Abfragen auch vom Compiler übersetzt.

    var  query  =  products 
                . Where ( p  =>  p . Name . StartsWith ( "A" )) 
                . OrderBy ( p  =>  p . ID ); 

  foreach  ( var  product  in  query )  { 
      Console . WriteLine ( product . Name ); 
  } 

Mit der Funktion Single kann ein einzelner Datensatz ermittelt werden. Folgendes Beispiel ermittelt den Datensatz mit der ID 1.

     Console . WriteLine ( products . Single ( p  =>  p . ID  ==  1 ). Name ); 

Falls aber die Abfrage mehrere Datensätze ermittelt, wird eine InvalidOperationException geworfen.
LINQ to XML [ Bearbeiten | Quelltext bearbeiten ]

Nachstehend ein Beispiel das zeigt, wie LINQ verwendet werden kann, um Informationen aus einer XML-Datei auszulesen. Als XML-Datei dient folgende XML-Beispieldatei. [18]

  <?xml version="1.0"?> 
<!-- purchase_order.xml --> 
<PurchaseOrder  PurchaseOrderNumber= "99503"  OrderDate= "1999-10-20" > 
  <Address  Type= "Shipping" > 
    <Name> Ellen Adams </Name> 
    <Street> 123 Maple Street </Street> 
    <City> Mill Valley </City> 
    <State> CA </State> 
    <Zip> 10999 </Zip> 
    <Country> USA </Country> 
  </Address> 
  <Address  Type= "Billing" > 
    <Name> Tai Yee </Name> 
    <Street> 8 Oak Avenue </Street> 
    <City> Old Town </City> 
    <State> PA </State> 
    <Zip> 95819 </Zip> 
    <Country> USA </Country> 
  </Address> 
  <DeliveryNotes> Please leave packages in shed by driveway. </DeliveryNotes> 
  <Items> 
    <Item  PartNumber= "872-AA" > 
      <ProductName> Lawnmower </ProductName> 
      <Quantity> 1 </Quantity> 
      <USPrice> 148.95 </USPrice> 
      <Comment> Confirm this is electric </Comment> 
    </Item> 
    <Item  PartNumber= "926-AA" > 
      <ProductName> Baby Monitor </ProductName> 
      <Quantity> 2 </Quantity> 
      <USPrice> 39.98 </USPrice> 
      <ShipDate> 1999-05-21 </ShipDate> 
    </Item> 
  </Items> 
</PurchaseOrder> 

Wollte man beispielsweise die Artikelnummern ( PartNumber ) aller Einträge vom Typ <Item> auslesen, könnte man folgenden C# Code verwenden [19] .

  XElement  purchaseOrder  =  XElement . Load ( "purchase_order.xml" ); 

IEnumerable < string >  items  =  
   from  item  in  purchaseOrder . Descendants ( "Item" ) 
   select  ( string ) item . Attribute ( "PartNumber" ); 

foreach  ( var  item  in  items ) 
{ 
   Console . WriteLine ( partNumbers . ElementAt ( i )); 
} 
// Output: 
// 872-AA 
// 926-AA 

Eine andere Möglichkeit, unter Zuhilfenahme einer bedingten Abfrage, wäre alle Artikel auszuwählen, deren Wert mehr als 100 Dollar beträgt. Zusätzlich könnte man das Resultat der Abfrage mittels orderby nach den Artikelnummern, sortieren.

  XElement  purchaseOrder  =  XElement . Load ( "purchase_order.xml" ); 

IEnumerable < XElement >  items  =  
   from  item  in  purchaseOrder . Descendants ( "Item" ) 
   where  ( int ) item . Element ( "Quantity" )  *  ( decimal ) item . Element ( "USPrice" )  >  100 
   orderby  ( string ) item . Element ( "PartNumber" ) 
   select  item ; 

foreach ( var  item  in  items ) 
{ 
   Console . WriteLine ( item . Attribute ( "PartNumber" ). Value ); 
} 
// Output: 
// 872-AA 

LINQ mit Rx [ Bearbeiten | Quelltext bearbeiten ]

Viele Erweiterungsmethoden von LINQ sind auch in Rx vorhanden. Im folgenden Beispiel wird eine Filterung mit Hilfe der Where()-Klausel durchgeführt:

  using  System ; 
using  System.Reactive.Subjects ; 
using  System.Reactive.Linq ; 

class  Program 
{ 
    // Helper functions 
    private  static  Func < int , bool >  isEven  =  n  =>  n % 2  ==  0 ; 
    private  static  Func < int , bool >  isOdd  =  n  =>  ! isEven ( n ); 
    private  static  Func < int , bool >  isDivisibleBy5  =  n  =>  n % 5  ==  0 ; 

    static  void  Main () 
    { 
        var  subject  =  new  Subject < int >(); 
        using ( subject . Where ( isEven ). Where ( isDivisibleBy5 ). Subscribe ( _  =>  Console . WriteLine ( "FizzBuzz" ))) 
        using ( subject . Where ( isEven ). Where (! isDivisibleBy5 ). Subscribe ( _  =>  Console . WriteLine ( "Fizz" ))) 
        using ( subject . Where ( isOdd ). Where ( isDivisibleBy5 ). Subscribe ( _  =>  Console . WriteLine ( "Buzz" ))) 
        using ( subject . Where ( isOdd ). Where (! isDivisibleBy5 ). Subscribe ( Console . WriteLine )) 
        { 
            Observable . Range ( 1 ,  100 ). Subscribe ( subject . OnNext ); 
        } 
    } 
} 

Die Erweiterungsmethoden von Rx sind zwar auf eine andere Monade definiert ( IObservable<T> statt IEnumerable<T> ), da die Bezeichnung der Erweiterungsmethoden jedoch identisch ist, kann auch die Comprehension Syntax von LINQ eingesetzt werden. Eine weitere Möglichkeit ist daher:

  using  System ; 
using  System.Text ; 
using  System.Reactive.Linq ; 

class  Program 
{ 
    static  string  IntToFizzBuzz ( int  n ) 
    { 
        return  new  StringBuilder ( 8 ) 
            . Append (( n  %  2  ==  0 )  ?  "Fizz"  :  string . Empty ) 
            . Append (( n  %  5  ==  0 )?  "Buzz"  :  string . Empty ) 
            . Append (( n  %  2  !=  0  &&  n  %  5  !=  0 )?  n . ToString ()  :  string . Empty ) 
            . ToString (); 
    } 

    static  void  Main ( string []  args ) 
    { 
        var  numbers  =  Observable . Range ( 1 ,  100 ); 
        var  fizzBuzz  =  from  n  in  numbers  select  IntToFizzBuzz ( n ); 
        fizzBuzz . Subscribe ( Console . WriteLine ); 
    } 
} 

Siehe auch [ Bearbeiten | Quelltext bearbeiten ]

    Parallel Extensions

Literatur [ Bearbeiten | Quelltext bearbeiten ]

    Özgür Aytekin: LINQ – Theorie und Praxis für Einsteiger . Addison-Wesley, München 2008, ISBN 978-3-8273-2616-4 .  
    Andreas Kühnel: Visual C# 2010 . Galileo Press, Bonn 2010, ISBN 978-3-8362-1552-7 , LINQ to Objects, S.   465–496.  
    Paolo Pialorsi, Marco Russo: Datenbankprogrammierung mit Microsoft LINQ . Microsoft Press Deutschland, Unterschleißheim 2008, ISBN 978-3-86645-428-6 .  
    Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol CA 2010, ISBN 978-0-7356-4057-3 .  
    Paolo Pialorsi: Entwicklerbuch Microsoft SharePoint 2010 . Microsoft Press Deutschland, Unterschleißheim 2011, ISBN 978-3-86645-545-0 , LINQ to SharePoint, S.   113–188.  
    Jesse Liberty, Paul Betts: Programming Reactive Extensions and LINQ . Apress, 2011, ISBN 978-1-4302-3747-1 , S.   184.  

Weblinks [ Bearbeiten | Quelltext bearbeiten ]

    LINQ (Language-Integrated Query). In: MSDN . Microsoft , abgerufen am 25. März 2013 (LINQ Homepage).  
    LINQPad. Abgerufen am 25. März 2013 (Komfortabler Editor zur Erstellung und Ausführung von LINQ-Skripten).  
    Don Box, Anders Hejlsberg : The LINQ Project. Microsoft , September 2005, abgerufen am 16. März 2013 (englisch, Informationsseite von Microsoft ).  
    Roger Jennings: Third-Party LINQ Providers. OakLeaf Systems, 27. März 2007, abgerufen am 16. März 2013 (englisch, Liste verschiedener LINQ-Provider außerhalb von Microsoft).  
    Jan Welker: LINQ to XML Teil 1 – Erstellen einer XML Datei. 19. Juni 2008, abgerufen am 16. März 2013 (Einführung in LINQ to XML; dreiteilige Artikelserie).  
    Jan Welker: LINQ to XML Teil 2 – Abfragen einer XML Datei. 21. Juni 2008, abgerufen am 16. März 2013 (Einführung in LINQ to XML; dreiteilige Artikelserie).  
    Jan Welker: LINQ to XML Teil 3 – Manipulieren einer XML Datei. 22. Juni 2008, abgerufen am 16. März 2013 (Einführung in LINQ to XML; dreiteilige Artikelserie).  
    Robert Mühsig: HowTo: O/R Mapper LINQ to SQL – Einführung & einfaches manuelles Mapping. Code Inside Blog, 15. Januar 2008, abgerufen am 16. März 2013 (deutschsprachige Einführung in LINQ to SQL).  
    James Hare: Demystifying LINQ. Tech.Pro, 14. März 2013, abgerufen am 16. März 2013 (englisch).  
    Richard Carr: LINQ Style Variance and Standard Deviation Operators. BlackWasp, 2. April 2013, abgerufen am 3. April 2013 (englisch, Erweiterungsmethoden zur Berechnung von Standardabweichung und Varianz mit LINQ).  

LINQ in anderen Programmiersprachen [ Bearbeiten | Quelltext bearbeiten ]

F#

    Query Expressions (F#). In: MSDN. Microsoft, abgerufen am 18. Mai 2014 (englisch, LINQ-Variante in F#).  

JavaScript , TypeScript

    Jinq. Abgerufen am 09. Februar 2017 [1]
    Breeze.js. Abgerufen am 18. Mai 2014 (englisch, Abfragen im LINQ-Stil für den HTML5 Web Storage).  
    linq.js. In: CodePlex. Abgerufen am 3. April 2013 (englisch, LINQ für JavaScript).  
    JSINQ. In: CodePlex. Abgerufen am 3. April 2013 (englisch, LINQ to Objects für JavaScript).  

Java

    Java Streams API [20]
    Quaere. Codehaus Foundation, abgerufen am 3. April 2013 (englisch).  
    JaQue – JAva integrated QUEry library. In: Google Code. Abgerufen am 3. April 2013 (englisch, LINQ to Objects; kompatibel mit Java 7 Closures).  
    jOOQ – Java Object Oriented Querying. Abgerufen am 3. April 2013 (englisch, LINQ to SQL).  
    Query DSL. Abgerufen am 3. April 2013 (englisch, unterstützt JPA , JDO und SQL ).  

PHP

    phinq. In: Google Code. Abgerufen am 3. April 2013 (englisch, LINQ für PHP).  
    PHPLinq. In: CodePlex. Abgerufen am 3. April 2013 (englisch, LINQ für PHP).  

Python

    asq. In: Google Code. Abgerufen am 3. April 2013 (englisch, Python Implementierung für LINQ to Objects und Parallel LINQ to Objects ).  

Einzelnachweise [ Bearbeiten | Quelltext bearbeiten ]

    Hochspringen ↑ Erik Meijer. Microsoft Research , abgerufen am 16. März 2013 (englisch).  
    ↑ Hochspringen nach: a b Paolo Pialorsi: Entwicklerbuch Microsoft SharePoint 2010 . Microsoft Press Deutschland, Unterschleißheim 2011, ISBN 978-3-86645-545-0 , LINQ to SharePoint, S.   115.  
    Hochspringen ↑ Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol California 2010, ISBN 978-0-7356-4057-3 , S.   5.  
    Hochspringen ↑ Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol California 2010, ISBN 978-0-7356-4057-3 , S.   8–17.  
    Hochspringen ↑ Paolo Pialorsi: Entwicklerbuch Microsoft SharePoint 2010 . Microsoft Press Deutschland, Unterschleißheim 2011, ISBN 978-3-86645-545-0 , LINQ to SharePoint, S.   115 (In Anlehnung).  
    Hochspringen ↑ Brian Beckman: Don’t fear the Monad. In: Channel9 . Microsoft , abgerufen am 20. März 2013 (englisch).  
    Hochspringen ↑ The Marvels of Monads. In: MSDN Blog. Microsoft , 10. Januar 2008, abgerufen am 20. März 2013 (englisch).  
    Hochspringen ↑ LINQ-Abfrageausdrücke (C#-Programmierhandbuch). In: MSDN. Microsoft, abgerufen am 21. März 2013 .  
    Hochspringen ↑ Query Expressions (F#). In: MSDN. Microsoft, abgerufen am 21. März 2013 (englisch).  
    Hochspringen ↑ Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol California 2010, ISBN 978-0-7356-4057-3 , S.   6–8.  
    Hochspringen ↑ Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol California 2010, ISBN 978-0-7356-4057-3 , S.   7.  
    Hochspringen ↑ Paolo Pialorsi: Entwicklerbuch Microsoft SharePoint 2010 . Microsoft Press Deutschland, Unterschleißheim 2011, ISBN 978-3-86645-545-0 , LINQ to SharePoint, S.   114.  
    Hochspringen ↑ Paolo Pialorsi, Marco Russo: Programming Microsoft LINQ in Microsoft .NET Framework 4 . Microsoft Press, Sebastopol California 2010, ISBN 978-0-7356-4057-3 , S.   241   ff.  
    Hochspringen ↑ Paolo Pialorsi: Entwicklerbuch Microsoft SharePoint 2010 . Microsoft Press Deutschland, Unterschleißheim 2011, ISBN 978-3-86645-545-0 , LINQ to SharePoint, S.   188   ff.  
    Hochspringen ↑ Enumerable.SelectMany-Methode. In: MSDN. Microsoft, abgerufen am 21. März 2013 .  
    Hochspringen ↑ Typen, die NULL-Werte zulassen (C#-Programmierhandbuch). In: MSDN. Microsoft, abgerufen am 21. März 2013 .  
    Hochspringen ↑ Nullable<T>-Struktur. In: MSDN. Microsoft, abgerufen am 21. März 2013 .  
    Hochspringen ↑ XML-Beispieldatei: Typischer Auftrag (LINQ to XML). MSDN , abgerufen am 16. März 2013 .  
    Hochspringen ↑ Übersicht über LINQ to XML. MSDN , abgerufen am 16. März 2013 .  
    Hochspringen ↑ Java Streams Preview vs .Net High-Order Programming with LINQ. Informatech Costa Rica, abgerufen am 3. April 2013 (englisch).  

Abgerufen von „ https://de.wikipedia.org/w/index.php?title=LINQ&oldid=173859405 “
Kategorien :

    .NET
    Datenbanksprache
    Beschreibungssprache

Navigationsmenü
Meine Werkzeuge

    Nicht angemeldet
    Diskussionsseite
    Beiträge
    Benutzerkonto erstellen
    Anmelden

Namensräume

    Artikel
    Diskussion

Varianten

Ansichten

    Lesen
    Bearbeiten
    Quelltext bearbeiten
    Versionsgeschichte

Mehr

Suche
Navigation

    Hauptseite
    Themenportale
    Von A bis Z
    Zufälliger Artikel

Mitmachen

    Artikel verbessern
    Neuen Artikel anlegen
    Autorenportal
    Hilfe
    Letzte Änderungen
    Kontakt
    Spenden

Werkzeuge

    Links auf diese Seite
    Änderungen an verlinkten Seiten
    Spezialseiten
    Permanenter Link
    Seiten­informationen
    Wikidata-Datenobjekt
    Artikel zitieren

Drucken/­exportieren

    Buch erstellen
    Als PDF herunterladen
    Druckversion

In anderen Sprachen

    العربية
    Čeština
    Dansk
    English
    Español
    فارسی
    Suomi
    Français
    עברית
    Íslenska
    Italiano
    日本語
    Nederlands
    Polski
    Português
    Русский
    Shqip
    Svenska
    Türkçe
    中文
    11 weitere 

Links bearbeiten

    Diese Seite wurde zuletzt am 10. Februar 2018 um 18:06 Uhr bearbeitet.
    Abrufstatistik

    Der Text ist unter der Lizenz „Creative Commons Attribution/Share Alike“ verfügbar; Informationen zu den Urhebern und zum Lizenzstatus eingebundener Mediendateien (etwa Bilder oder Videos) können im Regelfall durch Anklicken dieser abgerufen werden. Möglicherweise unterliegen die Inhalte jeweils zusätzlichen Bedingungen. Durch die Nutzung dieser Website erklären Sie sich mit den Nutzungsbedingungen und der Datenschutzrichtlinie einverstanden.
    Wikipedia® ist eine eingetragene Marke der Wikimedia Foundation Inc.

    Datenschutz
    Über Wikipedia
    Impressum
    Entwickler
    Stellungnahme zu Cookies
    Mobile Ansicht
    Vorschau aktivieren

    Wikimedia Foundation
    Powered by MediaWiki

